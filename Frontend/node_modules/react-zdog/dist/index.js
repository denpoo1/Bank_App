import Zdog from 'zdog';
import _extends from '@babel/runtime/helpers/esm/extends';
import React, { useContext, useEffect, useCallback, useRef, useState, useMemo, useImperativeHandle, useLayoutEffect } from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';

function applyProps(instance, newProps) {
  Zdog.extend(instance, newProps);
}
const createZdog = primitive => React.forwardRef((_ref, ref) => {
  let children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return useZdogPrimitive(primitive, children, rest, ref)[0];
});
function generateRandomHexColor() {
  const randomInt = Math.floor(Math.random() * 16777216);
  const hexColor = randomInt.toString(16).toUpperCase();
  const color = '#' + hexColor.padStart(6, '0');

  if (color === '#000000') {
    return generateRandomHexColor();
  } else {
    return '#' + hexColor.padStart(6, '0');
  }
}

const componentToHex = c => {
  let hex = c.toString(16);
  return hex.length == 1 ? '0' + hex : hex;
};

const rgbToHex = (r, g, b) => {
  return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
};
function createProxy(target, handleChange, parentProp) {
  return new Proxy(target, {
    set(obj, prop, value) {
      if (typeof value === 'object' && value !== null) {
        value = createProxy(value, handleChange);
      }

      handleChange(obj, prop, value, parentProp);
      obj[prop] = value;
      return true;
    },

    get(obj, prop) {
      if (typeof obj[prop] === 'object' && obj[prop] !== null) {
        return createProxy(obj[prop], handleChange, prop);
      }

      return obj[prop];
    }

  });
}
const getMousePos = (canvas, evt, canvas_ghost) => {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas_ghost.width,
    y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas_ghost.height
  };
};
const getPixel = (_ref2) => {
  let x = _ref2.x,
      y = _ref2.y,
      canvasContext = _ref2.canvasContext;
  let imageData = canvasContext.getImageData(x, y, 1, 1);
  let data = imageData.data;
  return rgbToHex(data[0], data[1], data[2]);
};

const stateContext = React.createContext();
const parentContext = React.createContext();
const ghostParentContext = React.createContext();
function useMeasure() {
  const ref = useRef();

  const _useState = useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0
  }),
        bounds = _useState[0],
        set = _useState[1];

  const _useState2 = useState(() => new ResizeObserver((_ref) => {
    let entry = _ref[0];
    return set(entry.contentRect);
  })),
        ro = _useState2[0];

  useEffect(() => {
    if (ref.current) ro.observe(ref.current);
    return () => ro.disconnect();
  }, [ref.current]);
  return [{
    ref
  }, bounds];
}
function useRender(fn, deps) {
  if (deps === void 0) {
    deps = [];
  }

  const state = useContext(stateContext);
  useEffect(() => {
    // Subscribe to the render-loop
    const unsubscribe = state.current.subscribe(fn); // Call subscription off on unmount

    return () => unsubscribe();
  }, deps);
}
function useZdog() {
  const state = useContext(stateContext);
  return state.current;
}
function useZdogPrimitive(primitive, children, props, ref) {
  const state = useContext(stateContext);
  const parent = useContext(parentContext);
  const ghostParent = useContext(ghostParentContext);
  const colorId = useMemo(() => generateRandomHexColor(), []);
  const hiddenNodeProps = useMemo(() => {
    return _extends({
      stroke: false
    }, props, {
      color: colorId,
      leftFace: colorId,
      rightFace: colorId,
      topFace: colorId,
      bottomFace: colorId
    });
  }, [colorId, props]);

  const _useState3 = useState(() => new primitive(props)),
        node = _useState3[0];

  const _useState4 = useState(() => new primitive(hiddenNodeProps)),
        ghost_node = _useState4[0];

  const syncGhostNode = (obj, prop, value, parentProp) => {
    if (parentProp) {
      ghost_node[parentProp][prop] = value;
    } else {
      ghost_node[prop] = value;
    }

    state.current.illu.updateRenderGraph();
  };

  const _useState5 = useState(() => createProxy(node, syncGhostNode)),
        proxyNode = _useState5[0];

  useImperativeHandle(ref, () => proxyNode);
  useLayoutEffect(() => {
    applyProps(node, props);

    if (parent) {
      state.current.illu.updateRenderGraph();
    }
  }, [props]);
  useLayoutEffect(() => {
    applyProps(ghost_node, hiddenNodeProps);
  }, [hiddenNodeProps]);
  useLayoutEffect(() => {
    if (!parent) return;
    parent.addChild(node);
    state.current.illu.updateGraph();
    return () => {
      parent.removeChild(node);
      parent.updateFlatGraph();
      state.current.illu.updateGraph();
    };
  }, [parent]);
  useEffect(() => {
    if (!parent) return;
    state.current.itemMap[colorId] = node;

    if (props.onClick) {
      state.current.clickEventMap[colorId] = props.onClick;
    }

    if (props.onPointerMove) {
      state.current.pointerMoveEventMap[colorId] = props.onPointerMove;
    }

    if (props.onPointerEnter) {
      state.current.pointerEnterEventMap[colorId] = props.onPointerEnter;
    }

    if (props.onPointerLeave) {
      state.current.pointerLeaveEventMap[colorId] = props.onPointerLeave;
    }

    return () => {
      delete state.current.itemMap[colorId];
      delete state.current.clickEventMap[colorId];
      delete state.current.pointerMoveEventMap[colorId];
      delete state.current.pointerEnterEventMap[colorId];
      delete state.current.pointerLeaveEventMap[colorId];
    };
  }, [props]);
  useLayoutEffect(() => {
    if (!ghostParent) return;
    ghostParent.addChild(ghost_node);
    state.current.illu_ghost.updateGraph();
    return () => {
      ghostParent.removeChild(ghost_node);
      ghostParent.updateFlatGraph();
      state.current.illu_ghost.updateGraph();
    };
  }, [ghostParent]);
  return [React.createElement(ghostParentContext.Provider, {
    key: colorId,
    value: ghost_node
  }, React.createElement(parentContext.Provider, {
    value: node
  }, children)), node, ghost_node];
}
function useInvalidate() {
  const state = useZdog();
  const invalidate = useCallback(() => state.illu.updateRenderGraph(), [state]);
  return invalidate;
}

const Illustration = React.memo((_ref) => {
  let children = _ref.children,
      style = _ref.style,
      resize = _ref.resize,
      _ref$element = _ref.element,
      Element = _ref$element === void 0 ? 'svg' : _ref$element,
      _ref$frameloop = _ref.frameloop,
      frameloop = _ref$frameloop === void 0 ? 'always' : _ref$frameloop,
      dragRotate = _ref.dragRotate,
      _ref$onDragMove = _ref.onDragMove,
      _onDragMove = _ref$onDragMove === void 0 ? () => {} : _ref$onDragMove,
      _ref$pointerEvents = _ref.pointerEvents,
      pointerEvents = _ref$pointerEvents === void 0 ? false : _ref$pointerEvents,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "style", "resize", "element", "frameloop", "dragRotate", "onDragMove", "pointerEvents"]);

  const canvas = useRef(); //ref to secondary canvas and 2d context

  const canvas_ghost = useRef();

  const _useState = useState(null),
        ghostCanvasContext = _useState[0],
        setGhostCanvasContext = _useState[1];

  useEffect(() => {
    setGhostCanvasContext(canvas_ghost.current.getContext('2d', {
      willReadFrequently: true
    }));
  }, []);

  const _useMeasure = useMeasure(),
        bind = _useMeasure[0],
        size = _useMeasure[1];

  const _useZdogPrimitive = useZdogPrimitive(Zdog.Anchor, children),
        result = _useZdogPrimitive[0],
        scene = _useZdogPrimitive[1],
        ghostScene = _useZdogPrimitive[2];

  const state = useRef({
    scene,
    illu: undefined,
    size: {},
    subscribers: [],
    subscribe: fn => {
      state.current.subscribers.push(fn);
      return () => state.current.subscribers = state.current.subscribers.filter(s => s !== fn);
    },
    illu_ghost: undefined,
    itemMap: {},
    clickEventMap: {},
    pointerMoveEventMap: {},
    pointerEnterEventMap: {},
    pointerLeaveEventMap: {},
    pointerEvents
  });
  useEffect(() => {
    state.current.size = size;

    if (state.current.illu) {
      state.current.illu.setSize(size.width, size.height);
      state.current.illu_ghost.setSize(size.width, size.height);

      if (frameloop === 'demand') {
        state.current.illu.updateRenderGraph();
        state.current.illu_ghost.updateRenderGraph();
      }
    }
  }, [size]);
  useEffect(() => {
    state.current.illu = new Zdog.Illustration(_extends({
      element: canvas.current,
      dragRotate,
      onDragMove: () => {
        state.current.illu_ghost.rotate = {
          x: state.current.illu.rotate.x,
          y: state.current.illu.rotate.y,
          z: state.current.illu.rotate.z
        };

        _onDragMove();
      }
    }, rest));
    state.current.illu.addChild(scene);
    state.current.illu.updateGraph();
    state.current.illu_ghost = new Zdog.Illustration(_extends({
      element: canvas_ghost.current
    }, rest));
    state.current.illu_ghost.addChild(ghostScene);
    state.current.illu_ghost.updateGraph();
    let frame;
    let active = true;

    function render(t) {
      const _state$current = state.current,
            size = _state$current.size,
            subscribers = _state$current.subscribers;

      if (size.width && size.height) {
        // Run local effects
        subscribers.forEach(fn => fn(t)); // Render scene

        if (frameloop !== 'demand') {
          state.current.illu.updateRenderGraph();
        }
      }

      if (active && frameloop !== 'demand') frame = requestAnimationFrame(render);
    } // Start render loop


    render();
    return () => {
      // Take no chances, the loop has got to stop if the component unmounts
      active = false;
      cancelAnimationFrame(frame);
    };
  }, [frameloop]); // Takes care of updating the main illustration

  useLayoutEffect(() => {
    state.current.illu && applyProps(state.current.illu, rest);
    state.current.illu_ghost && applyProps(state.current.illu_ghost, rest);
  }, [rest]);

  const click = e => {
    if (!pointerEvents) return;
    state.current.illu_ghost && state.current.illu_ghost.updateRenderGraph();
    const coords = getMousePos(canvas.current, e, canvas_ghost.current);
    const pixel = getPixel(_extends({}, coords, {
      canvasContext: ghostCanvasContext
    }));
    const colorId = pixel.toUpperCase();
    const clickEvent = state.current.clickEventMap[colorId];
    clickEvent && clickEvent(e, state.current.itemMap[colorId]);
  };

  const prevColorId = useRef(null);
  const pointerOnObj = useRef(null);

  const setPointerOnObj = newState => {
    pointerOnObj.current = newState;
  };

  const pointerMove = e => {
    if (!pointerEvents) return;
    state.current.illu_ghost && state.current.illu_ghost.updateRenderGraph();
    const coords = getMousePos(canvas.current, e, canvas_ghost.current);
    const pixel = getPixel(_extends({}, coords, {
      canvasContext: ghostCanvasContext
    }));
    const colorId = pixel.toUpperCase();

    if (colorId !== '#000000' && prevColorId.current !== colorId && pointerOnObj.current !== colorId) {
      const pointerEnterEvent = state.current.pointerEnterEventMap[colorId];
      pointerEnterEvent && pointerEnterEvent(e, state.current.itemMap[colorId]);
      setPointerOnObj(prevColorId.current);
    }

    if (prevColorId.current && prevColorId.current !== '#000000' && prevColorId.current !== colorId && pointerOnObj.current) {
      const pointerLeaveEvent = state.current.pointerLeaveEventMap[prevColorId.current];
      pointerLeaveEvent && pointerLeaveEvent(e, state.current.itemMap[prevColorId.current]);
    }

    const pointerMoveEvent = state.current.pointerMoveEventMap[colorId];
    pointerMoveEvent && pointerMoveEvent(e, state.current.itemMap[colorId]);
    prevColorId.current = colorId;
  };

  return React.createElement(React.Fragment, null, React.createElement("div", _extends({
    ref: bind.ref
  }, rest, {
    style: _extends({
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden',
      boxSizing: 'border-box'
    }, style)
  }), React.createElement(Element, {
    ref: canvas,
    style: {
      display: 'block',
      boxSizing: 'border-box'
    },
    width: size.width,
    height: size.height,
    onClick: click,
    onPointerMove: pointerMove
  }), state.current.illu && React.createElement(stateContext.Provider, {
    value: state,
    children: result
  })), React.createElement("canvas", {
    ref: canvas_ghost,
    style: {
      display: 'block',
      boxSizing: 'border-box',
      opacity: '0',
      position: 'fixed',
      zIndex: '1000',
      pointerEvents: 'none',
      background: 'black'
    },
    width: size.width,
    height: size.height
  }));
});

const Anchor = createZdog(Zdog.Anchor);
const Shape = createZdog(Zdog.Shape);
const Group = createZdog(Zdog.Group);
const Rect = createZdog(Zdog.Rect);
const RoundedRect = createZdog(Zdog.RoundedRect);
const Ellipse = createZdog(Zdog.Ellipse);
const Polygon = createZdog(Zdog.Polygon);
const Hemisphere = createZdog(Zdog.Hemisphere);
const Cylinder = createZdog(Zdog.Cylinder);
const Cone = createZdog(Zdog.Cone);
const Box = createZdog(Zdog.Box);

export { Anchor, Box, Cone, Cylinder, Ellipse, Group, Hemisphere, Illustration, Polygon, Rect, RoundedRect, Shape, useInvalidate, useRender, useZdog };
