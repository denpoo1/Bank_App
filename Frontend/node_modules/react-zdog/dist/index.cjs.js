'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Zdog = _interopDefault(require('zdog'));
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var React = require('react');
var React__default = _interopDefault(React);
var ResizeObserver = _interopDefault(require('resize-observer-polyfill'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));

function applyProps(instance, newProps) {
  Zdog.extend(instance, newProps);
}
var createZdog = function createZdog(primitive) {
  return React__default.forwardRef(function (_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutPropertiesLoose(_ref, ["children"]);

    return useZdogPrimitive(primitive, children, rest, ref)[0];
  });
};
function generateRandomHexColor() {
  var randomInt = Math.floor(Math.random() * 16777216);
  var hexColor = randomInt.toString(16).toUpperCase();
  var color = '#' + hexColor.padStart(6, '0');

  if (color === '#000000') {
    return generateRandomHexColor();
  } else {
    return '#' + hexColor.padStart(6, '0');
  }
}

var componentToHex = function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? '0' + hex : hex;
};

var rgbToHex = function rgbToHex(r, g, b) {
  return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
};
function createProxy(target, handleChange, parentProp) {
  return new Proxy(target, {
    set: function set(obj, prop, value) {
      if (typeof value === 'object' && value !== null) {
        value = createProxy(value, handleChange);
      }

      handleChange(obj, prop, value, parentProp);
      obj[prop] = value;
      return true;
    },
    get: function get(obj, prop) {
      if (typeof obj[prop] === 'object' && obj[prop] !== null) {
        return createProxy(obj[prop], handleChange, prop);
      }

      return obj[prop];
    }
  });
}
var getMousePos = function getMousePos(canvas, evt, canvas_ghost) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas_ghost.width,
    y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas_ghost.height
  };
};
var getPixel = function getPixel(_ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      canvasContext = _ref2.canvasContext;
  var imageData = canvasContext.getImageData(x, y, 1, 1);
  var data = imageData.data;
  return rgbToHex(data[0], data[1], data[2]);
};

var stateContext = React__default.createContext();
var parentContext = React__default.createContext();
var ghostParentContext = React__default.createContext();
function useMeasure() {
  var ref = React.useRef();

  var _useState = React.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0
  }),
      bounds = _useState[0],
      set = _useState[1];

  var _useState2 = React.useState(function () {
    return new ResizeObserver(function (_ref) {
      var entry = _ref[0];
      return set(entry.contentRect);
    });
  }),
      ro = _useState2[0];

  React.useEffect(function () {
    if (ref.current) ro.observe(ref.current);
    return function () {
      return ro.disconnect();
    };
  }, [ref.current]);
  return [{
    ref: ref
  }, bounds];
}
function useRender(fn, deps) {
  if (deps === void 0) {
    deps = [];
  }

  var state = React.useContext(stateContext);
  React.useEffect(function () {
    // Subscribe to the render-loop
    var unsubscribe = state.current.subscribe(fn); // Call subscription off on unmount

    return function () {
      return unsubscribe();
    };
  }, deps);
}
function useZdog() {
  var state = React.useContext(stateContext);
  return state.current;
}
function useZdogPrimitive(primitive, children, props, ref) {
  var state = React.useContext(stateContext);
  var parent = React.useContext(parentContext);
  var ghostParent = React.useContext(ghostParentContext);
  var colorId = React.useMemo(function () {
    return generateRandomHexColor();
  }, []);
  var hiddenNodeProps = React.useMemo(function () {
    return _extends({
      stroke: false
    }, props, {
      color: colorId,
      leftFace: colorId,
      rightFace: colorId,
      topFace: colorId,
      bottomFace: colorId
    });
  }, [colorId, props]);

  var _useState3 = React.useState(function () {
    return new primitive(props);
  }),
      node = _useState3[0];

  var _useState4 = React.useState(function () {
    return new primitive(hiddenNodeProps);
  }),
      ghost_node = _useState4[0];

  var syncGhostNode = function syncGhostNode(obj, prop, value, parentProp) {
    if (parentProp) {
      ghost_node[parentProp][prop] = value;
    } else {
      ghost_node[prop] = value;
    }

    state.current.illu.updateRenderGraph();
  };

  var _useState5 = React.useState(function () {
    return createProxy(node, syncGhostNode);
  }),
      proxyNode = _useState5[0];

  React.useImperativeHandle(ref, function () {
    return proxyNode;
  });
  React.useLayoutEffect(function () {
    applyProps(node, props);

    if (parent) {
      state.current.illu.updateRenderGraph();
    }
  }, [props]);
  React.useLayoutEffect(function () {
    applyProps(ghost_node, hiddenNodeProps);
  }, [hiddenNodeProps]);
  React.useLayoutEffect(function () {
    if (!parent) return;
    parent.addChild(node);
    state.current.illu.updateGraph();
    return function () {
      parent.removeChild(node);
      parent.updateFlatGraph();
      state.current.illu.updateGraph();
    };
  }, [parent]);
  React.useEffect(function () {
    if (!parent) return;
    state.current.itemMap[colorId] = node;

    if (props.onClick) {
      state.current.clickEventMap[colorId] = props.onClick;
    }

    if (props.onPointerMove) {
      state.current.pointerMoveEventMap[colorId] = props.onPointerMove;
    }

    if (props.onPointerEnter) {
      state.current.pointerEnterEventMap[colorId] = props.onPointerEnter;
    }

    if (props.onPointerLeave) {
      state.current.pointerLeaveEventMap[colorId] = props.onPointerLeave;
    }

    return function () {
      delete state.current.itemMap[colorId];
      delete state.current.clickEventMap[colorId];
      delete state.current.pointerMoveEventMap[colorId];
      delete state.current.pointerEnterEventMap[colorId];
      delete state.current.pointerLeaveEventMap[colorId];
    };
  }, [props]);
  React.useLayoutEffect(function () {
    if (!ghostParent) return;
    ghostParent.addChild(ghost_node);
    state.current.illu_ghost.updateGraph();
    return function () {
      ghostParent.removeChild(ghost_node);
      ghostParent.updateFlatGraph();
      state.current.illu_ghost.updateGraph();
    };
  }, [ghostParent]);
  return [React__default.createElement(ghostParentContext.Provider, {
    key: colorId,
    value: ghost_node
  }, React__default.createElement(parentContext.Provider, {
    value: node
  }, children)), node, ghost_node];
}
function useInvalidate() {
  var state = useZdog();
  var invalidate = React.useCallback(function () {
    return state.illu.updateRenderGraph();
  }, [state]);
  return invalidate;
}

var Illustration = React__default.memo(function (_ref) {
  var children = _ref.children,
      style = _ref.style,
      resize = _ref.resize,
      _ref$element = _ref.element,
      Element = _ref$element === void 0 ? 'svg' : _ref$element,
      _ref$frameloop = _ref.frameloop,
      frameloop = _ref$frameloop === void 0 ? 'always' : _ref$frameloop,
      dragRotate = _ref.dragRotate,
      _ref$onDragMove = _ref.onDragMove,
      _onDragMove = _ref$onDragMove === void 0 ? function () {} : _ref$onDragMove,
      _ref$pointerEvents = _ref.pointerEvents,
      pointerEvents = _ref$pointerEvents === void 0 ? false : _ref$pointerEvents,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "style", "resize", "element", "frameloop", "dragRotate", "onDragMove", "pointerEvents"]);

  var canvas = React.useRef(); //ref to secondary canvas and 2d context

  var canvas_ghost = React.useRef();

  var _useState = React.useState(null),
      ghostCanvasContext = _useState[0],
      setGhostCanvasContext = _useState[1];

  React.useEffect(function () {
    setGhostCanvasContext(canvas_ghost.current.getContext('2d', {
      willReadFrequently: true
    }));
  }, []);

  var _useMeasure = useMeasure(),
      bind = _useMeasure[0],
      size = _useMeasure[1];

  var _useZdogPrimitive = useZdogPrimitive(Zdog.Anchor, children),
      result = _useZdogPrimitive[0],
      scene = _useZdogPrimitive[1],
      ghostScene = _useZdogPrimitive[2];

  var state = React.useRef({
    scene: scene,
    illu: undefined,
    size: {},
    subscribers: [],
    subscribe: function subscribe(fn) {
      state.current.subscribers.push(fn);
      return function () {
        return state.current.subscribers = state.current.subscribers.filter(function (s) {
          return s !== fn;
        });
      };
    },
    illu_ghost: undefined,
    itemMap: {},
    clickEventMap: {},
    pointerMoveEventMap: {},
    pointerEnterEventMap: {},
    pointerLeaveEventMap: {},
    pointerEvents: pointerEvents
  });
  React.useEffect(function () {
    state.current.size = size;

    if (state.current.illu) {
      state.current.illu.setSize(size.width, size.height);
      state.current.illu_ghost.setSize(size.width, size.height);

      if (frameloop === 'demand') {
        state.current.illu.updateRenderGraph();
        state.current.illu_ghost.updateRenderGraph();
      }
    }
  }, [size]);
  React.useEffect(function () {
    state.current.illu = new Zdog.Illustration(_extends({
      element: canvas.current,
      dragRotate: dragRotate,
      onDragMove: function onDragMove() {
        state.current.illu_ghost.rotate = {
          x: state.current.illu.rotate.x,
          y: state.current.illu.rotate.y,
          z: state.current.illu.rotate.z
        };

        _onDragMove();
      }
    }, rest));
    state.current.illu.addChild(scene);
    state.current.illu.updateGraph();
    state.current.illu_ghost = new Zdog.Illustration(_extends({
      element: canvas_ghost.current
    }, rest));
    state.current.illu_ghost.addChild(ghostScene);
    state.current.illu_ghost.updateGraph();
    var frame;
    var active = true;

    function render(t) {
      var _state$current = state.current,
          size = _state$current.size,
          subscribers = _state$current.subscribers;

      if (size.width && size.height) {
        // Run local effects
        subscribers.forEach(function (fn) {
          return fn(t);
        }); // Render scene

        if (frameloop !== 'demand') {
          state.current.illu.updateRenderGraph();
        }
      }

      if (active && frameloop !== 'demand') frame = requestAnimationFrame(render);
    } // Start render loop


    render();
    return function () {
      // Take no chances, the loop has got to stop if the component unmounts
      active = false;
      cancelAnimationFrame(frame);
    };
  }, [frameloop]); // Takes care of updating the main illustration

  React.useLayoutEffect(function () {
    state.current.illu && applyProps(state.current.illu, rest);
    state.current.illu_ghost && applyProps(state.current.illu_ghost, rest);
  }, [rest]);

  var click = function click(e) {
    if (!pointerEvents) return;
    state.current.illu_ghost && state.current.illu_ghost.updateRenderGraph();
    var coords = getMousePos(canvas.current, e, canvas_ghost.current);
    var pixel = getPixel(_extends({}, coords, {
      canvasContext: ghostCanvasContext
    }));
    var colorId = pixel.toUpperCase();
    var clickEvent = state.current.clickEventMap[colorId];
    clickEvent && clickEvent(e, state.current.itemMap[colorId]);
  };

  var prevColorId = React.useRef(null);
  var pointerOnObj = React.useRef(null);

  var setPointerOnObj = function setPointerOnObj(newState) {
    pointerOnObj.current = newState;
  };

  var pointerMove = function pointerMove(e) {
    if (!pointerEvents) return;
    state.current.illu_ghost && state.current.illu_ghost.updateRenderGraph();
    var coords = getMousePos(canvas.current, e, canvas_ghost.current);
    var pixel = getPixel(_extends({}, coords, {
      canvasContext: ghostCanvasContext
    }));
    var colorId = pixel.toUpperCase();

    if (colorId !== '#000000' && prevColorId.current !== colorId && pointerOnObj.current !== colorId) {
      var pointerEnterEvent = state.current.pointerEnterEventMap[colorId];
      pointerEnterEvent && pointerEnterEvent(e, state.current.itemMap[colorId]);
      setPointerOnObj(prevColorId.current);
    }

    if (prevColorId.current && prevColorId.current !== '#000000' && prevColorId.current !== colorId && pointerOnObj.current) {
      var pointerLeaveEvent = state.current.pointerLeaveEventMap[prevColorId.current];
      pointerLeaveEvent && pointerLeaveEvent(e, state.current.itemMap[prevColorId.current]);
    }

    var pointerMoveEvent = state.current.pointerMoveEventMap[colorId];
    pointerMoveEvent && pointerMoveEvent(e, state.current.itemMap[colorId]);
    prevColorId.current = colorId;
  };

  return React__default.createElement(React__default.Fragment, null, React__default.createElement("div", _extends({
    ref: bind.ref
  }, rest, {
    style: _extends({
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden',
      boxSizing: 'border-box'
    }, style)
  }), React__default.createElement(Element, {
    ref: canvas,
    style: {
      display: 'block',
      boxSizing: 'border-box'
    },
    width: size.width,
    height: size.height,
    onClick: click,
    onPointerMove: pointerMove
  }), state.current.illu && React__default.createElement(stateContext.Provider, {
    value: state,
    children: result
  })), React__default.createElement("canvas", {
    ref: canvas_ghost,
    style: {
      display: 'block',
      boxSizing: 'border-box',
      opacity: '0',
      position: 'fixed',
      zIndex: '1000',
      pointerEvents: 'none',
      background: 'black'
    },
    width: size.width,
    height: size.height
  }));
});

var Anchor = createZdog(Zdog.Anchor);
var Shape = createZdog(Zdog.Shape);
var Group = createZdog(Zdog.Group);
var Rect = createZdog(Zdog.Rect);
var RoundedRect = createZdog(Zdog.RoundedRect);
var Ellipse = createZdog(Zdog.Ellipse);
var Polygon = createZdog(Zdog.Polygon);
var Hemisphere = createZdog(Zdog.Hemisphere);
var Cylinder = createZdog(Zdog.Cylinder);
var Cone = createZdog(Zdog.Cone);
var Box = createZdog(Zdog.Box);

exports.Anchor = Anchor;
exports.Box = Box;
exports.Cone = Cone;
exports.Cylinder = Cylinder;
exports.Ellipse = Ellipse;
exports.Group = Group;
exports.Hemisphere = Hemisphere;
exports.Illustration = Illustration;
exports.Polygon = Polygon;
exports.Rect = Rect;
exports.RoundedRect = RoundedRect;
exports.Shape = Shape;
exports.useInvalidate = useInvalidate;
exports.useRender = useRender;
exports.useZdog = useZdog;
